# Computational Methods
For solving problems of a computational nature. The problem must be:
- Solved within a finite amount of time
- Have inputs outputs and calculations 
- clearly defined
- considered if decomposition and abstraction are possible to apply
- considered what storage is needed and what data is being handled

## Visualisation
Visualistation can be any process that represents data or a problem, often in an illustrative way. Images and graphs help people solve complex tasks or understand models. For example drawing a diagram for an algorithm isntead of reading pseudocode.

Need to consider what form works best to avoid being innaccurate (e.g using MAT LAB for th), but it should still be simplistic and focus on the most important and clear data.

Examples
- https://visme.co/blog/best-data-visualizations/
- https://www.101computing.net/data-visualisation-algorithms/


## Performance modelling
Performance modelling (testing) evaluating if a program's performance and uses that knowledge to improve it. Uses simmulations of mathematical models for testing to reduce costs. Done by creating criteria and complting tests on an application.

Provides a cheaper and easier method of testing, since it can be done before the final system is fully implemented (but also its done on the final test). 

Examples: Stress testing can be done to test ‘erroneous’ scenarios of the program.

## Heuristics
Heuristics is finding a solution that is good enough when an optimal solution is unknown or impossible. Using approximate solutions to problems that aren't computational (infinite time solutions).Not useful for problems solvable with typical methods.

Example: Travelling Salesman Problem as well as the A* algorithm.

## Data Mining
Data mining is used for identifying patterns in large sets of data. Reveals underlying trends and relationships. Mining large data sets is costly on resources and processing power.

Examples are: Neural networks, statistics and data science.

## Pipelining
Pipelinig Breaks down a process into a series of subtasks. Output of one task feeds into the input of another task. Subtasks are dependent on each other, which can be a disadavantage.This allows multi core processors to use parallel processing.

Examples are: Blocked, running and waiting states in a processor queue.
